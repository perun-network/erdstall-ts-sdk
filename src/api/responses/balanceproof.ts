// SPDX-License-Identifier: Apache-2.0
"use strict";

import { ethers, Signer, utils } from "ethers";
import {
	TypedJSON,
	jsonObject,
	jsonMember,
	jsonBigIntMember,
} from "#erdstall/export/typedjson";
import { customJSON, ABIPacked } from "#erdstall/api/util";
import { ChainAssets } from "#erdstall/ledger/assets";
import { Address, Signature } from "#erdstall/ledger";
import { ErdstallObject, registerErdstallType } from "#erdstall/api";
import { Backend } from "#erdstall/ledger/backend";

const balanceProofsTypeName = "BalanceProofs";

// Balance is the value of funds for the account within epoch.
@jsonObject
export class Balance {
	@jsonBigIntMember() epoch: bigint;
	@jsonMember(Address) account: Address<Backend>;
	@jsonMember(Boolean) exit: boolean;
	@jsonMember(() => ChainAssets) values: ChainAssets;

	constructor(
		epoch: bigint,
		account: Address<Backend> | string,
		exit: boolean,
		values: ChainAssets,
	) {
		this.epoch = epoch;
		this.account = Address.ensure(account);
		this.exit = exit;
		this.values = values;
	}

	// (uint64,address,bool,tuple(address,bytes)[])
	asABI(): ErdstallBalance {
		throw new Error("not implemented");
		// return {
		// 	epoch: this.epoch.valueOf(),
		// 	account: this.account.toString(),
		// 	exit: this.exit,
		// 	tokens: this.values.asABI(),
		// };
	}

	packTagged(): ABIPacked {
		throw new Error("not implemented");
		// return new ABIEncoder(
		// 	["uint64", this.epoch],
		// 	this.account,
		// 	this.exit,
		// 	this.values,
		// ).pack("ErdstallBalance");
	}

	async sign(signer: Signer): Promise<BalanceProof> {
		throw new Error("not implemented");
		// const sig = await signer.signMessage(this.packTagged().keccak256());
		// return new BalanceProof(this, new Signature(sig));
	}
}

export interface ErdstallBalance {
	epoch: ethers.BigNumberish;
	account: string;
	exit: boolean;
	tokens: ErdstallToken[];
}

export interface ErdstallToken {
	token: string;
	value: ethers.utils.BytesLike;
}

export type ErdstallSignature = ethers.utils.BytesLike;

// A BalanceProof is generated by the Enclave at the end of each transaction
// phase for each account in the Erdstall system.
@jsonObject
export class BalanceProof {
	@jsonMember(Balance)
	readonly balance: Balance;
	@jsonMember(Signature)
	readonly sig: Signature<Backend>;

	constructor(balance: Balance, signature: Signature<Backend>) {
		this.balance = balance;
		this.sig = signature;
	}

	toEthProof(): [ErdstallBalance, ErdstallSignature] {
		return [this.balance.asABI(), this.sig.asABI()];
	}

	verify(tee: Address<Backend>): boolean {
		const signer = utils.verifyMessage(
			this.balance.packTagged().keccak256(),
			this.sig.toString(),
		);
		return signer === tee.toString();
	}
}

@jsonObject
export class BalanceProofs extends ErdstallObject {
	public map: Map<string, BalanceProof>;
	constructor() {
		super();
		this.map = new Map<string, BalanceProof>();
	}

	static toJSON(me: BalanceProofs): any {
		var obj: any = {};
		me.map.forEach((bp, addr) => {
			obj[addr] = JSON.parse(TypedJSON.stringify(bp, BalanceProof));
		});
		return obj;
	}

	static fromJSON(data: any): BalanceProofs {
		const bps = new BalanceProofs();
		for (const addr in data) {
			bps.map.set(
				addr,
				TypedJSON.parse(JSON.stringify(data[addr]), BalanceProof)!,
			);
		}
		return bps;
	}

	public objectType() {
		return BalanceProofs;
	}
	protected objectTypeName() {
		return balanceProofsTypeName;
	}
}

registerErdstallType(balanceProofsTypeName, BalanceProofs);
customJSON(BalanceProofs);
