// SPDX-License-Identifier: Apache-2.0
"use strict";

import { ethers, Signer } from "ethers";

import {
	ChainConfig,
	ChainProofChunk,
	ClientConfig,
} from "#erdstall/api/responses";
import { Address } from "#erdstall/crypto";
import { EthereumAddress } from "#erdstall/crypto/ethereum";
import { ChainAssets } from "#erdstall/ledger/assets";
import {
	Erdstall__factory,
	EthereumClient,
	LedgerWriteConn,
	TokenFetcher,
} from "#erdstall/ledger/backend/ethereum";
import { ErdstallBackendSession } from "#erdstall";
import { TransactionGenerator } from "#erdstall/utils";
import { Backend } from "#erdstall/ledger/backend/backends";

export const ErrUnitialisedClient = new Error("client unitialised");

export class EthereumSession
	extends EthereumClient
	implements ErdstallBackendSession<"ethereum">
{
	private readonly signer: Signer;
	protected erdstallConn: LedgerWriteConn;

	constructor(signer: Signer, erdstallConn: LedgerWriteConn) {
		super(signer, erdstallConn);
		this.signer = signer;
		this.erdstallConn = erdstallConn;
	}

	// Generates a unique random custodial account. Returns a signer, its
	// associated account's address, and the private key used for restoring
	// that account later using `restoreCustodialAccount()` or
	// `restoreCustodial()`.
	static generateCustodialAccount(): {
		signer: Signer;
		address: Address<"ethereum">;
		privateKey: string;
	} {
		let wallet = ethers.Wallet.createRandom();
		return {
			signer: wallet,
			address: EthereumAddress.fromString(wallet.address),
			privateKey: wallet.privateKey,
		};
	}

	// Restores a custodial account from its private key, as returned by
	// `generateCustodialAccount()` or `generateCustodial()`. Returns a signer
	// and the associated account's address.
	static restoreCustodialAccount(privateKey: string): {
		signer: Signer;
		address: Address<"ethereum">;
	} {
		let signer = new ethers.Wallet(privateKey);
		return { signer, address: EthereumAddress.fromString(signer.address) };
	}

	// Generates a unique random custodial wallet (the keys are held by the
	// session itself) and uses that for establishing a session. Returns the
	// session and the associated private key. The private key must be saved
	// and then reused with `Session.restoreCustodial()` to recreate a session
	// with the same account again.
	static generateCustodial(
		provider: ethers.providers.Provider | URL,
		erdstallConn: LedgerWriteConn,
	): {
		session: EthereumSession;
		privateKey: string;
		address: Address<"ethereum">;
	} {
		if (provider instanceof URL)
			provider = new ethers.providers.JsonRpcProvider(`${provider}`);

		let { signer, address, privateKey } =
			EthereumSession.generateCustodialAccount();

		signer.connect(provider);
		return {
			privateKey,
			session: new EthereumSession(signer, erdstallConn),
			address,
		};
	}

	// Creates a session from a custodial account generated by
	// `generateCustodial()` or `generateCustodialAccount()`.
	static restoreCustodial(
		provider: ethers.providers.Provider | URL,
		erdstallConn: LedgerWriteConn,
		privateKey: string,
	): {
		session: EthereumSession;
		address: Address<"ethereum">;
	} {
		if (provider instanceof URL)
			provider = new ethers.providers.JsonRpcProvider(`${provider}`);

		let { signer, address } =
			EthereumSession.restoreCustodialAccount(privateKey);
		const session = new EthereumSession(
			signer.connect(provider),
			erdstallConn,
		);

		return { session, address };
	}

	async deposit<B extends "ethereum">(
		backend: B,
		assets: ChainAssets,
	): Promise<TransactionGenerator<B>> {
		return this.erdstallConn.deposit(backend, assets);
	}

	async withdraw<B extends "ethereum">(
		backend: B,
		exitProof: ChainProofChunk[],
	): Promise<TransactionGenerator<B>> {
		return this.erdstallConn.withdraw(backend, exitProof);
	}
}

export function defaultEthereumSessionInitializer(
	config: ClientConfig,
	signer: Signer,
): EthereumSession {
	const erdstall = Erdstall__factory.connect(
		(config.chains[0] as ChainConfig<"ethereum">).data.contract.toString(),
		signer,
	);
	const ledgerWriter = new LedgerWriteConn(erdstall, new TokenFetcher());

	return new EthereumSession(signer, ledgerWriter);
}

export function mkDefaultEthereumSessionConstructor(signer: Signer): {
	backend: "ethereum";
	provider: ethers.providers.Provider | Signer;
	signer: Signer;
	initializer: (config: ClientConfig, signer: Signer) => EthereumSession;
} {
	return {
		backend: "ethereum",
		signer: signer,
		// TODO: Single source of truth for the session constructor.
		provider: signer,
		initializer: defaultEthereumSessionInitializer,
	};
}
